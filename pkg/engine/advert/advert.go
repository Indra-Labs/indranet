package advert

import (
	"fmt"
	"github.com/indra-labs/indra"
	"github.com/indra-labs/indra/pkg/crypto"
	"github.com/indra-labs/indra/pkg/crypto/nonce"
	"github.com/indra-labs/indra/pkg/crypto/sha256"
	"github.com/indra-labs/indra/pkg/engine/magic"
	log2 "github.com/indra-labs/indra/pkg/proc/log"
	"github.com/indra-labs/indra/pkg/util/slice"
	"github.com/indra-labs/indra/pkg/util/splice"
	"github.com/multiformats/go-multiaddr"
	"net/netip"
	"time"
)

const (
	AddressLen = nonce.IDLen +
		splice.AddrLen + 1 +
		slice.Uint64Len +
		crypto.SigLen
	PeerLen = magic.Len +
		nonce.IDLen +
		slice.Uint64Len +
		crypto.SigLen
	ServiceLen = nonce.IDLen +
		2*slice.Uint16Len +
		slice.Uint32Len +
		crypto.SigLen
)

var (
	log   = log2.GetLogger(indra.PathBase)
	fails = log.E.Chk
)

// Address entries are stored with an index generated by concatenating the bytes
// of the public key with a string path "/address/N" where N is the index of the
// address. This means hidden service introducers for values over zero.
// Hidden services have no value in the zero index, which is "<hash>/address/0".
type Address struct {
	ID        nonce.ID            // To ensure no repeating message
	Multiaddr multiaddr.Multiaddr // We only use a netip.AddrPort though.
	Index     byte                // This is the index in the slice from Peer.
	Expiry    time.Time           // zero for relay's public address (32 bit).
	Sig       crypto.SigBytes
}

func (a *Address) Decode(s *splice.Splice) (e error) {
	var addr *netip.AddrPort
	s.ReadID(&a.ID).ReadAddrPort(&addr).ReadByte(&a.Index).ReadTime(&a.Expiry)
	return
}

func (a *Address) Encode(s *splice.Splice) (e error) {
	var ip, port string
	if ip, e = a.Multiaddr.ValueForProtocol(multiaddr.P_IP4); fails(e) {
	}
	if ip == "" {
		if ip, e = a.Multiaddr.ValueForProtocol(multiaddr.P_IP6); fails(e) {
			return
		}
	}
	if port, e = a.Multiaddr.ValueForProtocol(multiaddr.P_TCP); fails(e) {
		return
	}
	var addr netip.AddrPort
	if addr, e = netip.ParseAddrPort(ip + ":" + port); fails(e) {
	}
	s.ID(a.ID).AddrPort(&addr).Byte(a.Index).Time(a.Expiry)
	return
}

func (a *Address) GetOnion() interface{} { return nil }

func (a *Address) Len() int { return AddressLen }

func (a *Address) Magic() string { return "" }

func (a *Address) Sign(prv *crypto.Prv) (e error) {
	s := splice.New(a.Len())
	if e = a.Encode(s); fails(e) {
		return
	}
	var b []byte
	if b, e = prv.Sign(s.GetUntil(s.GetCursor())); fails(e) {
		return
	}
	if len(b) != crypto.SigLen {
		return fmt.Errorf("signature incorrect length, got %d expected %d",
			len(b), crypto.SigLen)
	}
	copy(a.Sig[:], b)
	return nil
}

func (a *Address) Validate(s *splice.Splice) (pub *crypto.Pub) {
	h := sha256.Single(s.GetRange(0, nonce.IDLen+splice.AddrLen+1+
		slice.Uint64Len))
	var e error
	if pub, e = a.Sig.Recover(h); fails(e) {
	}
	return
}

// Peer is the root identity document for an Indra peer. It is indexed by the
// Identity field, its public key. The slices found below it are derived via
// concatenation of strings with the keys and hashing to generate a derived
// field index, used to search the DHT for matches.
//
// The data stored for Peer must be signed with the key claimed by the Identity.
// For hidden services the address fields are signed in the DHT by the hidden
// service from their introduction solicitation, and the index from the current
// set is given by the hidden service.
type Peer struct {
	nonce.ID  // To ensure no repeating message
	Identity  crypto.PubBytes
	RelayRate int
	Sig       crypto.SigBytes
	// Addresses - first is address, nil for hidden services,
	// hidden services have more than one, 6 or more are kept active.
	Addresses []*Address
	Services  []Service
}

func (p *Peer) Decode(s *splice.Splice) (e error) {
	var v uint64
	s.ReadID(&p.ID).ReadUint64(&v)
	s.ReadSignature(&p.Sig)
	p.RelayRate = int(v)
	return nil
}

func (p *Peer) Encode(s *splice.Splice) (e error) {
	s.ID(p.ID).Uint64(uint64(p.RelayRate))
	return nil
}

func (p *Peer) GetOnion() interface{} {
	return nil
}

func (p *Peer) Len() int {
	return PeerLen
}

func (p *Peer) Magic() string {
	return ""
}

func (p *Peer) Sign(prv *crypto.Prv) (e error) {
	s := splice.New(p.Len())
	if e = p.Encode(s); fails(e) {
		return
	}
	var b []byte
	if b, e = prv.Sign(s.GetUntil(s.GetCursor())); fails(e) {
		return
	}
	if len(b) != crypto.SigLen {
		return fmt.Errorf("signature incorrect length, got %d expected %d",
			len(b), crypto.SigLen)
	}
	copy(p.Sig[:], b)
	return nil
}

func (p *Peer) Validate(s *splice.Splice) (pk *crypto.Pub) {
	h := sha256.Single(s.GetRange(0, nonce.IDLen+slice.Uint64Len))
	var e error
	if pk, e = p.Sig.Recover(h); fails(e) {
	}
	return
}

// Service stores a specification for the fee rate and the service port, which
// must be a well known port to match with a type of service, eg 80 for web, 53
// for DNS, etc. These are also attached to the Peer entry via concatenating
// "/service/N" where N is the index of the entry. A zero value at an index
// signals to stop scanning for more subsequent values.
type Service struct {
	ID        nonce.ID // To ensure no repeating message
	Index     uint16   // This is the index in the slice from Peer.
	Port      uint16
	RelayRate uint32
	Sig       crypto.SigBytes
}

func (sv *Service) Decode(s *splice.Splice) (e error) {
	s.ReadID(&sv.ID).
		ReadUint16(&sv.Index).
		ReadUint16(&sv.Port).
		ReadUint32(&sv.RelayRate)
	return
}

func (sv *Service) Encode(s *splice.Splice) (e error) {
	s.ID(sv.ID).Uint16(sv.Index).Uint16(sv.Port).Uint32(sv.RelayRate)
	return
}

func (sv *Service) GetOnion() interface{} { return nil }

func (sv *Service) Len() int { return ServiceLen }

func (sv *Service) Magic() string { return "" }

func (sv *Service) Sign(prv *crypto.Prv) (e error) {
	s := splice.New(sv.Len())
	if e = sv.Encode(s); fails(e) {
		return
	}
	var b []byte
	if b, e = prv.Sign(s.GetUntil(s.GetCursor())); fails(e) {
		return
	}
	if len(b) != crypto.SigLen {
		return fmt.Errorf("signature incorrect length, got %d expected %d",
			len(b), crypto.SigLen)
	}
	copy(sv.Sig[:], b)
	return nil
}

func (sv *Service) Validate(s *splice.Splice) (pub *crypto.Pub) {
	h := sha256.Single(s.GetRange(0, nonce.IDLen+2*slice.Uint16Len+
		slice.Uint64Len))
	var e error
	if pub, e = sv.Sig.Recover(h); fails(e) {
	}
	return
}
