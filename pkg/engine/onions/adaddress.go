package onions

import (
	"fmt"
	"github.com/indra-labs/indra/pkg/crypto"
	"github.com/indra-labs/indra/pkg/crypto/nonce"
	"github.com/indra-labs/indra/pkg/crypto/sha256"
	"github.com/indra-labs/indra/pkg/engine/coding"
	"github.com/indra-labs/indra/pkg/engine/magic"
	"github.com/indra-labs/indra/pkg/engine/onions/reg"
	"github.com/indra-labs/indra/pkg/engine/sess"
	"github.com/indra-labs/indra/pkg/util/multi"
	"github.com/indra-labs/indra/pkg/util/qu"
	"github.com/indra-labs/indra/pkg/util/splice"
	"github.com/multiformats/go-multiaddr"
	"net/netip"
	"reflect"
)

const (
	AddressAdMagic = "adad"
	AddressAdLen   = magic.Len +
		nonce.IDLen +
		crypto.PubKeyLen +
		splice.AddrLen + 1 +
		crypto.SigLen
)

// AddressAd entries are stored with an index generated by concatenating the bytes
// of the public key with a string path "/address/N" where N is the index of the
// address. This means hidden service introducers for values over zero.
// Hidden services have no value in the zero index, which is "<hash>/address/0".
type AddressAd struct {
	ID   nonce.ID // To ensure no repeating message
	Key  *crypto.Pub
	Addr multiaddr.Multiaddr
	Sig  crypto.SigBytes
}

func (x *AddressAd) Decode(s *splice.Splice) (e error) {
	if e = magic.TooShort(s.Remaining(), AddressAdLen-magic.Len,
		PeerMagic); fails(e) {

		return
	}
	addr := &netip.AddrPort{}
	s.ReadID(&x.ID).
		ReadPubkey(&x.Key).
		ReadAddrPort(&addr).
		ReadSignature(&x.Sig)
	//cid.Parse(x.Key.ToBytes())
	var ap multiaddr.Multiaddr
	proto := "ip4"
	if addr.Addr().Is6() {
		proto = "ip6"
	}
	if ap, e = multiaddr.NewMultiaddr(
		"/" + proto + "/" + addr.Addr().String() +
			"/tcp/" + fmt.Sprint(addr.Port()),
	); fails(e) {
		return
	}
	x.Addr = multi.AddKeyToMultiaddr(ap, x.Key)
	return
}

func (x *AddressAd) Encode(s *splice.Splice) (e error) {
	log.T.S("encoding", reflect.TypeOf(x),
		x.ID, x.Sig,
	)
	x.Splice(s)
	return
}

func (x *AddressAd) GetOnion() interface{} { return x }

func (x *AddressAd) Gossip(sm *sess.Manager, c qu.C) {
	log.D.F("propagating peer info for %s",
		x.Key.ToBased32Abbreviated())
	Gossip(x, sm, c)
	log.T.Ln("finished broadcasting peer info")
}

func (x *AddressAd) Len() int { return AddressAdLen }

func (x *AddressAd) Magic() string { return AddressAdMagic }

func (x *AddressAd) Splice(s *splice.Splice) {
	x.SpliceWithoutSig(s)
	s.Signature(x.Sig)
}

func (x *AddressAd) SpliceWithoutSig(s *splice.Splice) {
	var e error
	var ap netip.AddrPort
	if ap, e = multi.AddrToAddrPort(x.Addr); fails(e) {
		return
	}
	s.Magic(AddressAdMagic).
		ID(x.ID).
		Pubkey(x.Key).
		AddrPort(&ap)
}

func (x *AddressAd) Validate() bool {
	s := splice.New(AddressAdLen - magic.Len)
	x.SpliceWithoutSig(s)
	hash := sha256.Single(s.GetUntil(s.GetCursor()))
	key, e := x.Sig.Recover(hash)
	if fails(e) {
		return false
	}
	if key.Equals(x.Key) {
		return true
	}
	return false
}

func NewAddressAd(id nonce.ID, key *crypto.Prv,
	ma multiaddr.Multiaddr) (peerAd *AddressAd) {

	pub := crypto.DerivePub(key)
	ma = multi.AddKeyToMultiaddr(ma, pub)
	log.D.Ln("ma", ma)
	peerAd = &AddressAd{
		ID:   id,
		Key:  pub,
		Addr: ma,
	}
	s := splice.New(IntroLen - magic.Len)
	peerAd.SpliceWithoutSig(s)
	hash := sha256.Single(s.GetUntil(s.GetCursor()))
	var e error
	if peerAd.Sig, e = crypto.Sign(key, hash); fails(e) {
		return nil
	}
	return
}

func addrGen() coding.Codec { return &AddressAd{} }

func init() { reg.Register(AddressAdMagic, addrGen) }
